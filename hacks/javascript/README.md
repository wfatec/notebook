# JavaScript 中有趣的特性

## 基本类型的包装类型

我们都知道 JS 有基本类型和引用类型两个大类，这里我们不讨论两者的区别，我想谈的是一个关于基本类型的有趣的现象，并从这个现象来发现一些特性。

当我们想要将十进制数字转化为十六进制字符串时，我们很自然的想到了`toString()`方法：

```js
const num = 97;
console.log(num.toString(16))
```

输出结果为`61`。看起来非常理所当然，但是我们进一步思考，如果直接执行

```js
console.log(97.toString(16))
```

会发生什么呢？

答案是会打印如下错误信息：

```
Uncaught SyntaxError: Invalid or unexpected token
```

说明这是一个语法错误！那么为什么先赋值给变量 `num` 再去执行`toString()` 就可以了呢？或者说这个简单的赋值语句到底做了哪些事情呢？这里由于未能找到较为有说服力的说明，只能暂时给出自己的理解。

基本类型在赋值给变量时，编译器会根据其类型调用相应的内置构造器，来实现变量的存储，但是此时的构造器与我们常用的函数构造器又有很大的区别，首先这个内置构造器生成的值是保存在栈中而非堆中，且基本类型的赋值过程中每次都会创建新的地址空间来存放新的赋值变量。这样设计是有原因的，因为基本类型往往比较小，因此这样的复制操作并不会占用太多资源空间。此外基本类型往往更改频繁，如果像引用类型一样需要通过引用地址在堆中进行查找(堆的存取速度大大慢于栈)，执行效率上会存在问题。

所以我们基于此大概知道了，虽然基本类型的赋值与引用类型不尽相同，但是其底层一定也有类似引用类型一样的构造器，从而实现基本类型的一些内置方法。而 `js` 也提供了基本类型的构造器函数供开发者调用。

```js
console.log(Number(97).toString(16))
```

此时方能输出正确的结果。而这个时候`Number(97)`实际上就做了类似变量赋值的处理。

```js
typeof Number(97) === "number"
```

而如果使用`new`来创建：

```js
console.log((new Number(97)).toString(16))
```

结果仍是正确的，但此时：

```js
typeof new Number(97) === "object"
```

可见，`new`方法会将基本类型的值转化为引用类型，而同时其内置方法也会继承过来。